package org.matheclipse.core.reflection.system.rulesets;

import static org.matheclipse.core.expression.F.*;
import org.matheclipse.core.interfaces.ISymbol;
import org.matheclipse.core.interfaces.IAST;
import org.matheclipse.core.patternmatching.Matcher;

/**
 * <p>Generated by <code>org.matheclipse.core.preprocessor.RulePreprocessor</code>.</p>
 * <p>See GIT repository at: <a href="https://github.com/axkr/symja_android_library">github.com/axkr/symja_android_library under the tools directory</a>.</p>
 */
public interface ProductRules {
public static Matcher init1() {
  Matcher matcher = new Matcher();    // Product(x_Symbol,{x_,0,m_}):=0
matcher.caseOf(Product(x_Symbol,list(x_,C0,m_)),
      C0);
    // Product(x_Symbol,{x_,0,m_,s_}):=0/;0<m
matcher.caseOf(Product(x_Symbol,List(x_,C0,m_,s_)),
      Condition(C0,Less(C0,m)));
    // Product(x_Symbol,{x_,1,n_}):=n!
matcher.caseOf(Product(x_Symbol,list(x_,C1,n_)),
      Factorial(n));
    // Product(x_Symbol,{x_,m_,n_}):=Pochhammer(m,1-m+n)
matcher.caseOf(Product(x_Symbol,list(x_,m_,n_)),
      Pochhammer(m,Plus(C1,Negate(m),n)));
    // Product(x_Symbol,{y_,m_,n_}):=x^(1-m+n)/;FreeQ({y,m,n},x)
matcher.caseOf(Product(x_Symbol,list(y_,m_,n_)),
      Condition(Power(x,Plus(C1,Negate(m),n)),FreeQ(list(y,m,n),x)));
    // Product(Cos(x_*2^i_),{i_Symbol,0,l_}):=Module({k=-1+l},(Csc(x)*Sin(2^k*x))/2^k/;(!NumericQ(l)||(IntegerQ(l)&&l>0))&&FreeQ({x,l},i))
matcher.caseOf(Product(Cos(Times(x_,Power(C2,i_))),list(i_Symbol,C0,l_)),
      Module(list(Set(k,Plus(CN1,l))),Condition(Times(Power(Power(C2,k),CN1),Csc(x),Sin(Times(Power(C2,k),x))),And(Or(Not(NumericQ(l)),And(IntegerQ(l),Greater(l,C0))),FreeQ(list(x,l),i)))));
return matcher;
}
}
