package org.matheclipse.core.interfaces;

import java.util.Collection;
import java.util.List;
import java.util.function.IntFunction;

import org.matheclipse.core.expression.F;

public interface IASTAppendable extends IASTMutable {
	/**
	 * Append an <code>subAST</code> with attribute <code>OneIdentity</code> for example Plus[] or Times[].
	 * 
	 * @param subAST
	 *            an ast with attribute <code>OneIdentity</code>.
	 * @return <code>this</code> ast after adding the subAST
	 */
	public IAST appendOneIdentity(IAST subAST);

	/**
	 * Adds the specified expression at the end of this {@code List}.
	 * 
	 * @param expr
	 *            the object to add.
	 * @return always true.
	 * @throws UnsupportedOperationException
	 *             if adding to this {@code List} is not supported.
	 * @throws ClassCastException
	 *             if the class of the object is inappropriate for this {@code List}.
	 * @throws IllegalArgumentException
	 *             if the object cannot be added to this {@code List}.
	 */
	public boolean append(IExpr expr);

	/**
	 * Inserts the specified object into this {@code List} at the specified location. The object is inserted before the
	 * current element at the specified location. If the location is equal to the size of this {@code List}, the object
	 * is added at the end. If the location is smaller than the size of this {@code List}, then all elements beyond the
	 * specified location are moved by one position towards the end of the {@code List}.
	 * 
	 * @param location
	 *            the index at which to insert.
	 * @param object
	 *            the object to add.
	 * @throws UnsupportedOperationException
	 *             if adding to this {@code List} is not supported.
	 * @throws ClassCastException
	 *             if the class of the object is inappropriate for this {@code List}.
	 * @throws IllegalArgumentException
	 *             if the object cannot be added to this {@code List}.
	 * @throws IndexOutOfBoundsException
	 *             if {@code location < 0 || location > size()}
	 */
	public void append(int location, IExpr object);

	/**
	 * Adds the objects in the specified collection to the end of this {@code List}. The objects are added in the order
	 * in which they are returned from the collection's iterator.
	 * 
	 * @param collection
	 *            the collection of objects.
	 * @return {@code true} if this {@code List} is modified, {@code false} otherwise (i.e. if the passed collection was
	 *         empty).
	 * @throws UnsupportedOperationException
	 *             if adding to this {@code List} is not supported.
	 * @throws ClassCastException
	 *             if the class of an object is inappropriate for this {@code List}.
	 * @throws IllegalArgumentException
	 *             if an object cannot be added to this {@code List}.
	 */
	public boolean appendAll(Collection<? extends IExpr> collection);

	/**
	 * Appends all elements from offset <code>startPosition</code> to <code>endPosition</code> in the specified AST to
	 * the end of this AST.
	 * 
	 * @param ast
	 *            AST containing elements to be added to this AST
	 * @param startPosition
	 *            the start position, inclusive.
	 * @param endPosition
	 *            the ending position, exclusive.
	 * @return <tt>true</tt> if this AST changed as a result of the call
	 * 
	 */
	public boolean appendAll(IAST ast, int startPosition, int endPosition);

	public boolean appendAll(int location, Collection<? extends IExpr> collection);

	/**
	 * Appends all elements from offset <code>startPosition</code> to <code>endPosition</code> in the specified list to
	 * the end of this AST.
	 * 
	 * @param list
	 *            list containing elements to be added to this AST
	 * @param startPosition
	 *            the start position, inclusive.
	 * @param endPosition
	 *            the ending position, exclusive.
	 * @return <tt>true</tt> if this AST changed as a result of the call
	 * 
	 */
	public boolean appendAll(List<? extends IExpr> list, int startPosition, int endPosition);

	/**
	 * Appends all of the arguments (starting from offset <code>1</code>) in the specified AST to the end of this AST.
	 * 
	 * @param ast
	 *            AST containing elements to be added to this AST
	 * @return <tt>true</tt> if this AST changed as a result of the call
	 * 
	 */
	public boolean appendArgs(IAST ast);

	/**
	 * Appends all elements generated by the given function from index <code>1</code> inclusive to <code>end</code>
	 * exclusive.
	 * 
	 * @param end
	 *            end index (exclusive)
	 * @param function
	 *            function which generates the elements which should be appended
	 * @return <tt>this</tt>
	 * 
	 */
	public IASTAppendable appendArgs(int end, IntFunction<IExpr> function);

	/**
	 * Appends all of the arguments (starting from offset <code>1</code>) in the specified AST up to position
	 * <code>untilPosition</code> exclusive.
	 * 
	 * @param ast
	 *            AST containing elements to be added to this AST
	 * @param untilPosition
	 *            append all argumments of ast up to position <code>untilPosition</code> exclusive.
	 * 
	 * @return <tt>true</tt> if this AST changed as a result of the call
	 * 
	 */
	public boolean appendArgs(IAST ast, int untilPosition);

	/**
	 * Appends all elements generated by the given function from index <code>start</code> inclusive to <code>end</code>
	 * exclusive.
	 * 
	 * @param start
	 *            start index (inclusive)
	 * @param end
	 *            end index (exclusive)
	 * @param function
	 *            function which generates the elements which should be appended
	 * @return <tt>this</tt>
	 * 
	 */
	default IASTAppendable appendArgs(int start, int end, IntFunction<IExpr> function) {
		for (int i = start; i < end; i++) {
			append(function.apply(i));
		}
		return this;
	}

	default boolean appendPlus(IExpr expr) {
		if (head().equals(F.Plus) && expr.head().equals(F.Plus)) {
			return appendArgs((IAST) expr);
		}
		return append(expr);
	}

	/**
	 * Removes all elements from this {@code IAST}, leaving it empty (optional).
	 * 
	 * @throws UnsupportedOperationException
	 *             if removing from this {@code Collection} is not supported.
	 */
	public void clear();

	/**
	 * Get the range of elements [1..ast.size()[. These range elements are the arguments of a function (represented as
	 * an AST).
	 * 
	 * @return
	 */
	// public ASTRange args();

	/**
	 * Get the range of elements [0..ast.size()[ of the AST. This range elements are the head of the function prepended
	 * by the arguments of a function.
	 * 
	 * @return
	 */
	// public ASTRange range();

	/**
	 * Get the range of elements [start..sizeOfAST[ of the AST
	 * 
	 * @param start
	 *            the ranges start position (inclusive)
	 * @return
	 */
	// public ASTRange range(int start);

	/**
	 * Get the range of elements [start..end[ of the AST
	 * 
	 * @param start
	 *            the ranges start position ((inclusive)
	 * @param end
	 *            the ranges end position (exclusive)
	 * @return
	 */
	// public ASTRange range(int start, int end);

	/**
	 * Removes the object at the specified location from this {@code IAST}.
	 * 
	 * @param location
	 *            the index of the object to remove.
	 * @return the removed object.
	 * @throws UnsupportedOperationException
	 *             if removing from this {@code IAST} is not supported.
	 * @throws IndexOutOfBoundsException
	 *             if {@code location < 0 || >= size()}
	 */
	public IExpr remove(int location);

	/**
	 * Removes the objects in the specified range from the start to the end, but not including the end index.
	 * 
	 * @param start
	 *            the index at which to start removing.
	 * @param end
	 *            the index one after the end of the range to remove.
	 * @throws IndexOutOfBoundsException
	 *             when {@code start < 0, start > end} or {@code end > size()}
	 */
	public void removeRange(int start, int end);
}
