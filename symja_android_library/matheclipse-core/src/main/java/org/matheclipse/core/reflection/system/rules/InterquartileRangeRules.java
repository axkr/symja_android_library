package org.matheclipse.core.reflection.system.rules;

import static org.matheclipse.core.expression.F.And;
import static org.matheclipse.core.expression.F.BernoulliDistribution;
import static org.matheclipse.core.expression.F.C0;
import static org.matheclipse.core.expression.F.C1;
import static org.matheclipse.core.expression.F.C1D2;
import static org.matheclipse.core.expression.F.C1D4;
import static org.matheclipse.core.expression.F.C2;
import static org.matheclipse.core.expression.F.C3;
import static org.matheclipse.core.expression.F.C4;
import static org.matheclipse.core.expression.F.CN1;
import static org.matheclipse.core.expression.F.CSqrt2;
import static org.matheclipse.core.expression.F.ExponentialDistribution;
import static org.matheclipse.core.expression.F.GumbelDistribution;
import static org.matheclipse.core.expression.F.IInit;
import static org.matheclipse.core.expression.F.ISet;
import static org.matheclipse.core.expression.F.ISetDelayed;
import static org.matheclipse.core.expression.F.InterquartileRange;
import static org.matheclipse.core.expression.F.InverseErfc;
import static org.matheclipse.core.expression.F.Less;
import static org.matheclipse.core.expression.F.LessEqual;
import static org.matheclipse.core.expression.F.List;
import static org.matheclipse.core.expression.F.Log;
import static org.matheclipse.core.expression.F.NormalDistribution;
import static org.matheclipse.core.expression.F.Piecewise;
import static org.matheclipse.core.expression.F.Power;
import static org.matheclipse.core.expression.F.QQ;
import static org.matheclipse.core.expression.F.Times;
import static org.matheclipse.core.expression.F.m_;
import static org.matheclipse.core.expression.F.n_;
import static org.matheclipse.core.expression.S.InterquartileRange;
import static org.matheclipse.core.expression.S.m;
import static org.matheclipse.core.expression.S.n;
import org.matheclipse.core.interfaces.IAST;

/**
 * <p>
 * Generated by <code>org.matheclipse.core.preprocessor.RulePreprocessor</code>.
 * </p>
 * <p>
 * See GIT repository at:
 * <a href="https://github.com/axkr/symja_android_library">github.com/axkr/symja_android_library
 * under the tools directory</a>.
 * </p>
 */
public interface InterquartileRangeRules {
  /**
   * <ul>
   * <li>index 0 - number of equal rules in <code>RULES</code></li>
   * </ul>
   */
  final public static int[] SIZES = {1, 4};

  final public static IAST RULES = List(IInit(InterquartileRange, SIZES),
      // InterquartileRange(BernoulliDistribution(n_)):=Piecewise({{1,1/4<n<=3/4}},0)
      ISetDelayed(InterquartileRange(BernoulliDistribution(n_)),
          Piecewise(List(List(C1, And(Less(C1D4, n), LessEqual(n, QQ(3L, 4L))))), C0)),
      // InterquartileRange(ExponentialDistribution(n_))=Log(3)/n
      ISet(InterquartileRange(ExponentialDistribution(n_)), Times(Power(n, CN1), Log(C3))),
      // InterquartileRange(GumbelDistribution()):=Log(Log(4)/Log(4/3))
      ISetDelayed(InterquartileRange(GumbelDistribution()),
          Log(Times(Power(Log(QQ(4L, 3L)), CN1), Log(C4)))),
      // InterquartileRange(GumbelDistribution(n_,m_)):=m*Log(Log(4)/Log(4/3))
      ISetDelayed(InterquartileRange(GumbelDistribution(n_, m_)),
          Times(m, Log(Times(Power(Log(QQ(4L, 3L)), CN1), Log(C4))))),
      // InterquartileRange(NormalDistribution(n_,m_)):=2*Sqrt(2)*m*InverseErfc(1/2)
      ISetDelayed(InterquartileRange(NormalDistribution(n_, m_)),
          Times(C2, CSqrt2, m, InverseErfc(C1D2))));
}
