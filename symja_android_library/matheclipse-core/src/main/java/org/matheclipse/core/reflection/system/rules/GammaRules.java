package org.matheclipse.core.reflection.system.rules;

import static org.matheclipse.core.expression.F.C0;
import static org.matheclipse.core.expression.F.C1;
import static org.matheclipse.core.expression.F.C1D2;
import static org.matheclipse.core.expression.F.C2;
import static org.matheclipse.core.expression.F.CComplexInfinity;
import static org.matheclipse.core.expression.F.CI;
import static org.matheclipse.core.expression.F.CN1;
import static org.matheclipse.core.expression.F.CN1D2;
import static org.matheclipse.core.expression.F.CN2;
import static org.matheclipse.core.expression.F.CNI;
import static org.matheclipse.core.expression.F.Condition;
import static org.matheclipse.core.expression.F.DirectedInfinity;
import static org.matheclipse.core.expression.F.Erfc;
import static org.matheclipse.core.expression.F.Exp;
import static org.matheclipse.core.expression.F.Gamma;
import static org.matheclipse.core.expression.F.Greater;
import static org.matheclipse.core.expression.F.IInit;
import static org.matheclipse.core.expression.F.ISet;
import static org.matheclipse.core.expression.F.ISetDelayed;
import static org.matheclipse.core.expression.F.List;
import static org.matheclipse.core.expression.F.Negate;
import static org.matheclipse.core.expression.F.Noo;
import static org.matheclipse.core.expression.F.PatternTest;
import static org.matheclipse.core.expression.F.Plus;
import static org.matheclipse.core.expression.F.Power;
import static org.matheclipse.core.expression.F.QQ;
import static org.matheclipse.core.expression.F.Re;
import static org.matheclipse.core.expression.F.Sqrt;
import static org.matheclipse.core.expression.F.Subfactorial;
import static org.matheclipse.core.expression.F.Subtract;
import static org.matheclipse.core.expression.F.Times;
import static org.matheclipse.core.expression.F.a_;
import static org.matheclipse.core.expression.F.oo;
import static org.matheclipse.core.expression.F.x_;
import static org.matheclipse.core.expression.F.y_;
import static org.matheclipse.core.expression.F.z_;
import static org.matheclipse.core.expression.S.E;
import static org.matheclipse.core.expression.S.Gamma;
import static org.matheclipse.core.expression.S.Indeterminate;
import static org.matheclipse.core.expression.S.NumericQ;
import static org.matheclipse.core.expression.S.Pi;
import static org.matheclipse.core.expression.S.Undefined;
import static org.matheclipse.core.expression.S.a;
import static org.matheclipse.core.expression.S.x;
import static org.matheclipse.core.expression.S.y;
import static org.matheclipse.core.expression.S.z;
import org.matheclipse.core.interfaces.IAST;

/**
 * <p>
 * Generated by <code>org.matheclipse.core.preprocessor.RulePreprocessor</code>.
 * </p>
 * <p>
 * See GIT repository at:
 * <a href="https://github.com/axkr/symja_android_library">github.com/axkr/symja_android_library
 * under the tools directory</a>.
 * </p>
 */
public interface GammaRules {
  /**
   * <ul>
   * <li>index 0 - number of equal rules in <code>RULES</code></li>
   * </ul>
   */
  final public static int[] SIZES = {12, 4};

  final public static IAST RULES = List(IInit(Gamma, SIZES),
      // Gamma(Undefined)=Undefined
      ISet(Gamma(Undefined), Undefined),
      // Gamma(-5/2)=(-1)*1/15*8*Sqrt(Pi)
      ISet(Gamma(QQ(-5L, 2L)), Times(QQ(-8L, 15L), Sqrt(Pi))),
      // Gamma(-3/2)=1/3*4*Sqrt(Pi)
      ISet(Gamma(QQ(-3L, 2L)), Times(QQ(4L, 3L), Sqrt(Pi))),
      // Gamma(-1/2)=-2*Sqrt(Pi)
      ISet(Gamma(CN1D2), Times(CN2, Sqrt(Pi))),
      // Gamma(1/2)=Sqrt(Pi)
      ISet(Gamma(C1D2), Sqrt(Pi)),
      // Gamma(3/2)=Sqrt(Pi)/2
      ISet(Gamma(QQ(3L, 2L)), Times(C1D2, Sqrt(Pi))),
      // Gamma(5/2)=1/4*3*Sqrt(Pi)
      ISet(Gamma(QQ(5L, 2L)), Times(QQ(3L, 4L), Sqrt(Pi))),
      // Gamma(Infinity)=Infinity
      ISet(Gamma(oo), oo),
      // Gamma(-Infinity)=Indeterminate
      ISet(Gamma(Noo), Indeterminate),
      // Gamma(I*Infinity)=0
      ISet(Gamma(DirectedInfinity(CI)), C0),
      // Gamma(-I*Infinity)=0
      ISet(Gamma(DirectedInfinity(CNI)), C0),
      // Gamma(ComplexInfinity)=Indeterminate
      ISet(Gamma(CComplexInfinity), Indeterminate),
      // Gamma(Undefined,y_):=Undefined
      ISetDelayed(Gamma(Undefined, y_), Undefined),
      // Gamma(x_,Undefined):=Undefined
      ISetDelayed(Gamma(x_, Undefined), Undefined),
      // Gamma(a_,-1):=E*Subfactorial(-1+a)
      ISetDelayed(Gamma(a_, CN1), Times(E, Subfactorial(Plus(CN1, a)))),
      // Gamma(a_,Infinity):=0
      ISetDelayed(Gamma(a_, oo), C0),
      // Gamma(1/2,z_?NumericQ):=Sqrt(Pi)*Erfc(Sqrt(z))
      ISetDelayed(Gamma(C1D2, PatternTest(z_, NumericQ)), Times(Sqrt(Pi), Erfc(Sqrt(z)))),
      // Gamma(-1/2,z_?NumericQ):=2/(E^z*Sqrt(z))-2*Sqrt(Pi)*Erfc(Sqrt(z))
      ISetDelayed(Gamma(CN1D2, PatternTest(z_, NumericQ)),
          Plus(Times(C2, Power(Times(Exp(z), Sqrt(z)), CN1)), Times(CN2, Sqrt(Pi), Erfc(Sqrt(z))))),
      // Gamma(1,z_):=E^(-z)
      ISetDelayed(Gamma(C1, z_), Exp(Negate(z))),
      // Gamma(a_,z_,0):=-Gamma(a)+Gamma(a,z)/;Re(a)>0
      ISetDelayed(Gamma(a_, z_, C0),
          Condition(Plus(Negate(Gamma(a)), Gamma(a, z)), Greater(Re(a), C0))),
      // Gamma(a_,z_,Infinity):=Gamma(a,z)
      ISetDelayed(Gamma(a_, z_, oo), Gamma(a, z)),
      // Gamma(a_,Infinity,z_):=-Gamma(a,z)
      ISetDelayed(Gamma(a_, oo, z_), Negate(Gamma(a, z))),
      // Gamma(a_,0,Infinity):=Gamma(a)/;Re(a)>0
      ISetDelayed(Gamma(a_, C0, oo), Condition(Gamma(a), Greater(Re(a), C0))),
      // Gamma(a_,0,z_):=Gamma(a)-Gamma(a,z)/;Re(a)>0
      ISetDelayed(Gamma(a_, C0, z_),
          Condition(Subtract(Gamma(a), Gamma(a, z)), Greater(Re(a), C0))),
      // Gamma(a_,x_,y_):=Gamma(a,x)-Gamma(a,y)
      ISetDelayed(Gamma(a_, x_, y_), Subtract(Gamma(a, x), Gamma(a, y))));
}
