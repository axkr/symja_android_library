package org.matheclipse.core.reflection.system.rulesets;

import static org.matheclipse.core.expression.F.*;
import org.matheclipse.core.interfaces.ISymbol;
import org.matheclipse.core.interfaces.IAST;
import org.matheclipse.core.patternmatching.Matcher;

/**
 * <p>
 * Generated by <code>org.matheclipse.core.preprocessor.RulePreprocessor</code>.
 * </p>
 * <p>
 * See GIT repository at:
 * <a href="https://github.com/axkr/symja_android_library">github.com/axkr/symja_android_library
 * under the tools directory</a>.
 * </p>
 */
public interface ProductRules {
  public static Matcher init1() {
    Matcher matcher = new Matcher(); // Product(x_Symbol,{x_,0,m_}):=0
    matcher.caseOf(Product(x_Symbol, List(x_, C0, m_)), C0);
    // Product(x_Symbol,{x_,0,m_,s_}):=0/;0<m
    matcher.caseOf(Product(x_Symbol, List(x_, C0, m_, s_)), Condition(C0, Less(C0, m)));
    // Product(x_Symbol,{x_,m_,n_}):=Pochhammer(m,1-m+n)/;FreeQ({m,n},x)
    matcher.caseOf(Product(x_Symbol, List(x_, m_, n_)),
        Condition(Pochhammer(m, Plus(C1, Negate(m), n)), FreeQ(List(m, n), x)));
    // Product(x_Symbol,{y_,m_,n_}):=x^(1-m+n)/;FreeQ({y,m,n},x)
    matcher.caseOf(Product(x_Symbol, List(y_, m_, n_)),
        Condition(Power(x, Plus(C1, Negate(m), n)), FreeQ(List(y, m, n), x)));
    return matcher;
  }
}
