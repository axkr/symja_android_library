package org.matheclipse.core.reflection.system.rules;

import static org.matheclipse.core.expression.F.BernoulliDistribution;
import static org.matheclipse.core.expression.F.C0;
import static org.matheclipse.core.expression.F.C1;
import static org.matheclipse.core.expression.F.C1D2;
import static org.matheclipse.core.expression.F.C2;
import static org.matheclipse.core.expression.F.CN1;
import static org.matheclipse.core.expression.F.CN1D2;
import static org.matheclipse.core.expression.F.CSqrt2;
import static org.matheclipse.core.expression.F.CauchyDistribution;
import static org.matheclipse.core.expression.F.ConditionalExpression;
import static org.matheclipse.core.expression.F.Equal;
import static org.matheclipse.core.expression.F.ErlangDistribution;
import static org.matheclipse.core.expression.F.Exp;
import static org.matheclipse.core.expression.F.ExponentialDistribution;
import static org.matheclipse.core.expression.F.FrechetDistribution;
import static org.matheclipse.core.expression.F.Function;
import static org.matheclipse.core.expression.F.GammaDistribution;
import static org.matheclipse.core.expression.F.Greater;
import static org.matheclipse.core.expression.F.GumbelDistribution;
import static org.matheclipse.core.expression.F.IInit;
import static org.matheclipse.core.expression.F.ISetDelayed;
import static org.matheclipse.core.expression.F.InverseBetaRegularized;
import static org.matheclipse.core.expression.F.InverseErfc;
import static org.matheclipse.core.expression.F.InverseGammaRegularized;
import static org.matheclipse.core.expression.F.Less;
import static org.matheclipse.core.expression.F.LessEqual;
import static org.matheclipse.core.expression.F.List;
import static org.matheclipse.core.expression.F.Log;
import static org.matheclipse.core.expression.F.LogNormalDistribution;
import static org.matheclipse.core.expression.F.NakagamiDistribution;
import static org.matheclipse.core.expression.F.Negate;
import static org.matheclipse.core.expression.F.NormalDistribution;
import static org.matheclipse.core.expression.F.Piecewise;
import static org.matheclipse.core.expression.F.Plus;
import static org.matheclipse.core.expression.F.Power;
import static org.matheclipse.core.expression.F.Quantile;
import static org.matheclipse.core.expression.F.Slot1;
import static org.matheclipse.core.expression.F.Sqrt;
import static org.matheclipse.core.expression.F.StudentTDistribution;
import static org.matheclipse.core.expression.F.Subtract;
import static org.matheclipse.core.expression.F.Tan;
import static org.matheclipse.core.expression.F.Times;
import static org.matheclipse.core.expression.F.WeibullDistribution;
import static org.matheclipse.core.expression.F.a_;
import static org.matheclipse.core.expression.F.b_;
import static org.matheclipse.core.expression.F.d_;
import static org.matheclipse.core.expression.F.g_;
import static org.matheclipse.core.expression.F.k_;
import static org.matheclipse.core.expression.F.l_;
import static org.matheclipse.core.expression.F.m_;
import static org.matheclipse.core.expression.F.n_;
import static org.matheclipse.core.expression.F.oo;
import static org.matheclipse.core.expression.F.s_;
import static org.matheclipse.core.expression.F.v_;
import static org.matheclipse.core.expression.F.w_;
import static org.matheclipse.core.expression.F.x_;
import static org.matheclipse.core.expression.S.Pi;
import static org.matheclipse.core.expression.S.Quantile;
import static org.matheclipse.core.expression.S.a;
import static org.matheclipse.core.expression.S.b;
import static org.matheclipse.core.expression.S.d;
import static org.matheclipse.core.expression.S.g;
import static org.matheclipse.core.expression.S.k;
import static org.matheclipse.core.expression.S.l;
import static org.matheclipse.core.expression.S.m;
import static org.matheclipse.core.expression.S.n;
import static org.matheclipse.core.expression.S.s;
import static org.matheclipse.core.expression.S.v;
import static org.matheclipse.core.expression.S.w;
import static org.matheclipse.core.expression.S.x;
import org.matheclipse.core.interfaces.IAST;

/**
 * <p>
 * Generated by <code>org.matheclipse.core.preprocessor.RulePreprocessor</code>.
 * </p>
 * <p>
 * See GIT repository at:
 * <a href="https://github.com/axkr/symja_android_library">github.com/axkr/symja_android_library
 * under the tools directory</a>.
 * </p>
 */
public interface QuantileRules {
  /**
   * <ul>
   * <li>index 0 - number of equal rules in <code>RULES</code></li>
   * </ul>
   */
  final public static int[] SIZES = {0, 16};

  final public static IAST RULES = List(IInit(Quantile, SIZES),
      // Quantile(BernoulliDistribution(x_)):=ConditionalExpression(Piecewise({{1,#1>1-x}},0),0<=#1<=1)&
      ISetDelayed(Quantile(BernoulliDistribution(x_)),
          Function(
              ConditionalExpression(Piecewise(List(List(C1, Greater(Slot1, Subtract(C1, x)))), C0),
                  LessEqual(C0, Slot1, C1)))),
      // Quantile(CauchyDistribution(a_,b_)):=ConditionalExpression(Piecewise({{a+b*Tan((-1/2+#1)*Pi),0<#1<1},{-Infinity,#1<=0}},Infinity),0<=#1<=1)&
      ISetDelayed(Quantile(CauchyDistribution(a_, b_)),
          Function(ConditionalExpression(
              Piecewise(
                  List(List(Plus(a, Times(b, Tan(Times(Plus(CN1D2, Slot1), Pi)))),
                      Less(C0, Slot1, C1)), List(Negate(oo), LessEqual(Slot1, C0))),
                  oo),
              LessEqual(C0, Slot1, C1)))),
      // Quantile(ErlangDistribution(k_,l_)):=ConditionalExpression(Piecewise({{InverseGammaRegularized(k,0,#1)/l,0<#1<1},{0,#1<=0}},Infinity),0<=#1<=1)&
      ISetDelayed(Quantile(ErlangDistribution(k_, l_)),
          Function(ConditionalExpression(
              Piecewise(List(
                  List(Times(Power(l, CN1),
                      InverseGammaRegularized(k, C0, Slot1)), Less(C0, Slot1, C1)),
                  List(C0, LessEqual(Slot1, C0))), oo),
              LessEqual(C0, Slot1, C1)))),
      // Quantile(ExponentialDistribution(n_)):=ConditionalExpression(Piecewise({{-Log(1-#1)/n,#1<1}},Infinity),0<=#1<=1)&
      ISetDelayed(Quantile(ExponentialDistribution(n_)),
          Function(ConditionalExpression(Piecewise(
              List(List(Times(CN1, Power(n, CN1), Log(Subtract(C1, Slot1))), Less(Slot1, C1))), oo),
              LessEqual(C0, Slot1, C1)))),
      // Quantile(FrechetDistribution(n_,m_)):=ConditionalExpression(Piecewise({{m/(-Log(#1))^(1/n),0<#1<1},{0,#1<=0}},Infinity),0<=#1<=1)&
      ISetDelayed(Quantile(FrechetDistribution(n_, m_)),
          Function(ConditionalExpression(
              Piecewise(List(
                  List(Times(m, Power(Power(Negate(Log(Slot1)), Power(n, CN1)), CN1)),
                      Less(C0, Slot1, C1)),
                  List(C0, LessEqual(Slot1, C0))), oo),
              LessEqual(C0, Slot1, C1)))),
      // Quantile(GammaDistribution(a_,b_)):=ConditionalExpression(Piecewise({{b*InverseGammaRegularized(a,0,#1),0<#1<1},{0,#1<=0}},Infinity),0<=#1<=1)&
      ISetDelayed(
          Quantile(GammaDistribution(a_,
              b_)),
          Function(ConditionalExpression(Piecewise(
              List(List(Times(b, InverseGammaRegularized(a, C0, Slot1)), Less(C0, Slot1, C1)),
                  List(C0, LessEqual(Slot1, C0))),
              oo), LessEqual(C0, Slot1, C1)))),
      // Quantile(GammaDistribution(a_,b_,g_,d_)):=ConditionalExpression(Piecewise({{d+b*InverseGammaRegularized(a,0,#1)^(1/g),0<#1<1},{d,#1<=0}},Infinity),0<=#1<=1)&
      ISetDelayed(
          Quantile(GammaDistribution(a_, b_, g_,
              d_)),
          Function(
              ConditionalExpression(
                  Piecewise(
                      List(List(
                          Plus(d,
                              Times(b,
                                  Power(InverseGammaRegularized(a, C0, Slot1), Power(g, CN1)))),
                          Less(C0, Slot1, C1)), List(d, LessEqual(Slot1, C0))),
                      oo),
                  LessEqual(C0, Slot1, C1)))),
      // Quantile(GumbelDistribution()):=ConditionalExpression(Piecewise({{Log(-Log(1-#1)),0<#1<1},{-Infinity,#1<=0}},Infinity),0<=#1<=1)&
      ISetDelayed(Quantile(GumbelDistribution()),
          Function(ConditionalExpression(
              Piecewise(List(List(Log(Negate(Log(Subtract(C1, Slot1)))), Less(C0, Slot1, C1)),
                  List(Negate(oo), LessEqual(Slot1, C0))), oo),
              LessEqual(C0, Slot1, C1)))),
      // Quantile(GumbelDistribution(a_,b_)):=ConditionalExpression(Piecewise({{a+b*Log(-Log(1-#1)),0<#1<1},{-Infinity,#1<=0}},Infinity),0<=#1<=1)&
      ISetDelayed(Quantile(GumbelDistribution(a_, b_)),
          Function(ConditionalExpression(
              Piecewise(List(List(Plus(a, Times(b, Log(Negate(Log(Subtract(C1, Slot1)))))),
                  Less(C0, Slot1, C1)), List(Negate(oo), LessEqual(Slot1, C0))), oo),
              LessEqual(C0, Slot1, C1)))),
      // Quantile(LogNormalDistribution(m_,d_)):=ConditionalExpression(Piecewise({{E^(m-Sqrt(2)*d*InverseErfc(2*#1)),0<#1<1},{0,#1<=0}},Infinity),0<=#1<=1)&
      ISetDelayed(Quantile(LogNormalDistribution(m_, d_)), Function(ConditionalExpression(
          Piecewise(List(List(Exp(Plus(m, Times(CN1, CSqrt2, d, InverseErfc(Times(C2, Slot1))))),
              Less(C0, Slot1, C1)), List(C0, LessEqual(Slot1, C0))), oo),
          LessEqual(C0, Slot1, C1)))),
      // Quantile(NakagamiDistribution(m_,w_)):=ConditionalExpression(Piecewise({{Sqrt((w*InverseGammaRegularized(m,0,#1))/m),0<#1<1},{0,#1<=0}},Infinity),0<=#1<=1)&
      ISetDelayed(Quantile(NakagamiDistribution(m_, w_)), Function(ConditionalExpression(
          Piecewise(List(List(Sqrt(Times(Power(m, CN1), w, InverseGammaRegularized(m, C0, Slot1))),
              Less(C0, Slot1, C1)), List(C0, LessEqual(Slot1, C0))), oo),
          LessEqual(C0, Slot1, C1)))),
      // Quantile(NormalDistribution(m_,s_)):=ConditionalExpression(m-Sqrt(2)*s*InverseErfc(2*#1),0<=#1<=1)&
      ISetDelayed(Quantile(NormalDistribution(m_, s_)),
          Function(
              ConditionalExpression(Plus(m, Times(CN1, CSqrt2, s, InverseErfc(Times(C2, Slot1)))),
                  LessEqual(C0, Slot1, C1)))),
      // Quantile(StudentTDistribution(v_)):=ConditionalExpression(Piecewise({{-Sqrt(v)*Sqrt(-1+1/InverseBetaRegularized(2*#1,v/2,1/2)),0<#1<1/2},{0,#1==1/2},{Sqrt(v)*Sqrt(-1+1/InverseBetaRegularized(2*(1-#1),v/2,1/2)),1/2<#1<1},{-Infinity,#1<=0}},Infinity),0<=#1<=1)&
      ISetDelayed(
          Quantile(StudentTDistribution(
              v_)),
          Function(
              ConditionalExpression(
                  Piecewise(
                      List(
                          List(
                              Times(CN1, Sqrt(v),
                                  Sqrt(
                                      Plus(CN1,
                                          Power(
                                              InverseBetaRegularized(Times(C2, Slot1),
                                                  Times(C1D2, v), C1D2),
                                              CN1)))),
                              Less(C0, Slot1, C1D2)),
                          List(C0, Equal(Slot1, C1D2)),
                          List(Times(Sqrt(v),
                              Sqrt(Plus(CN1,
                                  Power(InverseBetaRegularized(Times(C2, Subtract(C1, Slot1)),
                                      Times(C1D2, v), C1D2), CN1)))),
                              Less(C1D2, Slot1, C1)),
                          List(Negate(oo), LessEqual(Slot1, C0))),
                      oo),
                  LessEqual(C0, Slot1, C1)))),
      // Quantile(StudentTDistribution(m_,s_,v_)):=ConditionalExpression(Piecewise({{m-s*Sqrt(v)*Sqrt(-1+1/InverseBetaRegularized(2*#1,v/2,1/2)),0<#1<1/2},{m,#1==1/2},{m+s*Sqrt(v)*Sqrt(-1+1/InverseBetaRegularized(2*(1-#1),v/2,1/2)),1/2<#1<1},{-Infinity,#1<=0}},Infinity),0<=#1<=1)&
      ISetDelayed(
          Quantile(StudentTDistribution(m_, s_,
              v_)),
          Function(
              ConditionalExpression(
                  Piecewise(
                      List(
                          List(
                              Plus(m,
                                  Times(CN1, s, Sqrt(v),
                                      Sqrt(Plus(CN1,
                                          Power(InverseBetaRegularized(Times(C2, Slot1),
                                              Times(C1D2, v), C1D2), CN1))))),
                              Less(C0, Slot1, C1D2)),
                          List(m, Equal(Slot1, C1D2)),
                          List(Plus(m,
                              Times(s, Sqrt(v),
                                  Sqrt(Plus(CN1,
                                      Power(InverseBetaRegularized(Times(C2, Subtract(C1, Slot1)),
                                          Times(C1D2, v), C1D2), CN1))))),
                              Less(C1D2, Slot1, C1)),
                          List(Negate(oo), LessEqual(Slot1, C0))),
                      oo),
                  LessEqual(C0, Slot1, C1)))),
      // Quantile(WeibullDistribution(a_,b_)):=ConditionalExpression(Piecewise({{b*(-Log(1-#1))^(1/a),0<#1<1},{0,#1<=0}},Infinity),0<=#1<=1)&
      ISetDelayed(Quantile(WeibullDistribution(a_, b_)), Function(
          ConditionalExpression(
              Piecewise(List(List(Times(b, Power(Negate(Log(Subtract(C1, Slot1))), Power(a, CN1))),
                  Less(C0, Slot1, C1)), List(C0, LessEqual(Slot1, C0))), oo),
              LessEqual(C0, Slot1, C1)))),
      // Quantile(WeibullDistribution(a_,b_,m_)):=ConditionalExpression(Piecewise({{m+b*(-Log(1-#1))^(1/a),0<#1<1},{m,#1<=0}},Infinity),0<=#1<=1)&
      ISetDelayed(
          Quantile(WeibullDistribution(a_, b_,
              m_)),
          Function(ConditionalExpression(
              Piecewise(List(
                  List(Plus(m, Times(b, Power(Negate(Log(Subtract(C1, Slot1))), Power(a, CN1)))),
                      Less(C0, Slot1, C1)),
                  List(m, LessEqual(Slot1, C0))), oo),
              LessEqual(C0, Slot1, C1)))));
}
