package org.matheclipse.core.interfaces;

import com.duy.lambda.BiPredicate;
import com.duy.lambda.Consumer;
import com.duy.lambda.ObjIntConsumer;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

/**
 * Created by Duy on 2/20/2018.
 */

public abstract class IASTImpl extends IExprImpl implements IAST {

    @Override
    public abstract IAST clone() throws CloneNotSupportedException;

    /**
     * Tests whether this {@code Collection} contains all objects contained in the specified {@code Collection}. This
     * implementation iterates over the specified {@code Collection}. If one element returned by the iterator is not
     * contained in this {@code Collection}, then {@code false} is returned; {@code true} otherwise.
     *
     * @param collection the collection of objects.
     * @return {@code true} if all objects in the specified {@code Collection} are elements of this {@code Collection},
     * {@code false} otherwise.
     * @throws ClassCastException   if one or more elements of {@code collection} isn't of the correct type.
     * @throws NullPointerException if {@code collection} contains at least one {@code null} element and this {@code Collection} doesn't
     *                              support {@code null} elements.
     * @throws NullPointerException if {@code collection} is {@code null}.
     */
    public boolean containsAll(Collection<?> collection) {
        Iterator<?> it = collection.iterator();
        while (it.hasNext()) {
            if (!contains(it.next())) {
                return false;
            }
        }
        return true;
    }


    /**
     * Returns a shallow copy of this <code>IAST</code> instance (the elements themselves are not copied). In contrast
     * to the <code>clone()</code> method, this method returns exactly the same type for
     * <code>AST0, AST1, AST2,AST3</code>.
     *
     * @return a copy of this <code>IAST</code> instance.
     */
    @Override
    public IASTMutable copy() {
        return copyAppendable();
    }

    /**
     * Copy the arguments of this AST to a list.
     *
     * @return
     */
    public List<IExpr> copyTo() {
        return (List<IExpr>) copyTo(new ArrayList<IExpr>(size()));
    }

    /**
     * Copy the arguments of this AST to a given collection object.
     *
     * @param collection
     * @return
     */
    public Collection<IExpr> copyTo(Collection<IExpr> collection) {
        for (int i = 1; i < size(); i++) {
            collection.add(get(i));
        }
        return collection;
    }

    /**
     * Compare the arguments pairwise with the <code>stopPredicate</code>. If the predicate gives <code>true</code>
     * return <code>true</code>. If the <code>stopPredicate</code> gives false for each pairwise comparison return the
     * <code>false</code> at the end.
     */
    public boolean existsLeft(BiPredicate<IExpr, IExpr> stopPredicate) {
        int size = size();
        for (int i = 2; i < size; i++) {
            if (stopPredicate.test(get(i - 1), get(i))) {
                return true;
            }
        }
        return false;
    }

    /**
     * Consume all elements generated by the given function from index <code>1</code> inclusive to <code>end</code>
     * exclusive.
     *
     * @param end    end index (exclusive)
     * @param action function which accepts the elements
     * @return <tt>this</tt>
     */
    public void forEach(int end, Consumer<? super IExpr> action) {
        forEach(1, end, action);
    }

    /**
     * Consume all elements generated by the given function from index <code>start</code> inclusive to <code>end</code>
     * exclusive.
     *
     * @param start  start index (inclusive)
     * @param end    end index (exclusive)
     * @param action function which accepts the elements
     */
    public void forEach(int start, int end, Consumer<? super IExpr> action) {
        for (int i = start; i < end; i++) {
            action.accept(get(i));
        }
    }

    public void forEach(int start, int end, ObjIntConsumer<? super IExpr> action) {
        for (int i = start; i < end; i++) {
            action.accept(get(i), i);
        }
    }

    public void forEach(int end, ObjIntConsumer<? super IExpr> action) {
        forEach(1, end, action);
    }

    public void forEach(ObjIntConsumer<? super IExpr> action) {
        forEach(1, size(), action);
    }


    /**
     * Test if the last argument contains a pattern with a default argument.
     *
     * @return
     */
    public boolean haspublicArgument() {
        if (size() > 1) {
            return get(size() - 1).isPatternDefault();
        }
        return false;
    }

    /**
     * Test if one of the arguments gives <code>true</code> for the <code>isNumericArgument()</code> method
     *
     * @return <code>true</code> if one of the arguments gives <code>true</code> for the
     * <code>isNumericArgument()</code> method
     */
    public boolean hasNumericArgument() {
        int size = size();
        for (int i = 1; i < size; i++) {
            if (get(i).isNumericArgument()) {
                return true;
            }
        }
        return false;
    }

    /**
     * Test if the last argument contains a pattern with an optional argument. (i.e. <code>x_:value</code>)
     *
     * @return
     */
    public boolean hasOptionalArgument() {
        if (size() > 1) {
            return get(size() - 1).isPatternDefault();
        }
        return false;
    }

    /**
     * Check if the object at index 0 (i.e. the head of the list) is the same object as <code>head</code> and if the
     * size of the list is greater or equal <code>length</code>.
     *
     * @param head   object to compare with element at location <code>0</code>
     * @param length
     * @return
     */
    @Override
    public boolean isSameHeadSizeGE(IExpr head, int length) {
        int size = size();
        return head().equals(head) && length <= size;
    }

    /**
     * Maps the elements of this IAST with the unary functor <code>Functors.replaceArg(replacement, position)</code>,
     * there <code>replacement</code> is an IAST at which the argument at the given position will be replaced by the
     * currently mapped element and appends the element to <code>appendAST</code>.
     *
     * @param appendAST
     * @param replacement an IAST there the argument at the given position is replaced by the currently mapped argument of this
     *                    IAST.
     * @param position
     * @return <code>appendAST</code>
     * @deprecated use IAST#mapThread() instead
     */
    @Deprecated
    public IAST mapAt(IASTAppendable appendAST, final IAST replacement, int position) {
        return mapThread(appendAST, replacement, position);
    }

    public IAST mapAt(final IASTAppendable replacement, int position) {
        return mapThread(replacement, position);
    }

    /**
     * Create a shallow copy of this <code>IAST</code> instance (the elements themselves are not copied) and set the
     * <code>expr</code> at the given <code>position</code>. In contrast to the <code>setAtClone()</code> method, this
     * method returns exactly the same type for <code>AST0, AST1, AST2, AST3</code>.
     *
     * @param i
     * @param expr
     * @return a copy with element set to <code>expr</code> at the given <code>position</code>.
     */
    public IASTMutable setAtCopy(int i, IExpr expr) {
        IASTMutable ast = (IASTMutable) copy();
        ast.set(i, expr);
        return ast;
    }
}
