package org.matheclipse.core.reflection.system.rulesets;

import static org.matheclipse.core.expression.F.C0;
import static org.matheclipse.core.expression.F.C1;
import static org.matheclipse.core.expression.F.Condition;
import static org.matheclipse.core.expression.F.FreeQ;
import static org.matheclipse.core.expression.F.Less;
import static org.matheclipse.core.expression.F.List;
import static org.matheclipse.core.expression.F.Negate;
import static org.matheclipse.core.expression.F.Plus;
import static org.matheclipse.core.expression.F.Pochhammer;
import static org.matheclipse.core.expression.F.Power;
import static org.matheclipse.core.expression.F.Product;
import static org.matheclipse.core.expression.F.m_;
import static org.matheclipse.core.expression.F.n_;
import static org.matheclipse.core.expression.F.s_;
import static org.matheclipse.core.expression.F.x_;
import static org.matheclipse.core.expression.F.x_Symbol;
import static org.matheclipse.core.expression.F.y_;
import static org.matheclipse.core.expression.S.m;
import static org.matheclipse.core.expression.S.n;
import static org.matheclipse.core.expression.S.x;
import static org.matheclipse.core.expression.S.y;
import org.matheclipse.core.patternmatching.Matcher;

/**
 * <p>
 * Generated by <code>org.matheclipse.core.preprocessor.RulePreprocessor</code>.
 * </p>
 * <p>
 * See GIT repository at:
 * <a href="https://github.com/axkr/symja_android_library">github.com/axkr/symja_android_library
 * under the tools directory</a>.
 * </p>
 */
public interface ProductRules {
  public static Matcher init1() {
    Matcher matcher = new Matcher(); // Product(x_Symbol,{x_,0,m_}):=0
    matcher.caseOf(Product(x_Symbol, List(x_, C0, m_)), C0);
    // Product(x_Symbol,{x_,0,m_,s_}):=0/;0<m
    matcher.caseOf(Product(x_Symbol, List(x_, C0, m_, s_)), Condition(C0, Less(C0, m)));
    // Product(x_Symbol,{x_,m_,n_}):=Pochhammer(m,1-m+n)/;FreeQ({m,n},x)
    matcher.caseOf(Product(x_Symbol, List(x_, m_, n_)),
        Condition(Pochhammer(m, Plus(C1, Negate(m), n)), FreeQ(List(m, n), x)));
    // Product(x_Symbol,{y_,m_,n_}):=x^(1-m+n)/;FreeQ({y,m,n},x)
    matcher.caseOf(Product(x_Symbol, List(y_, m_, n_)),
        Condition(Power(x, Plus(C1, Negate(m), n)), FreeQ(List(y, m, n), x)));
    return matcher;
  }
}
