package org.matheclipse.core.reflection.system.rules;

import static org.matheclipse.core.expression.F.And;
import static org.matheclipse.core.expression.F.C0;
import static org.matheclipse.core.expression.F.C1;
import static org.matheclipse.core.expression.F.CC;
import static org.matheclipse.core.expression.F.CComplexInfinity;
import static org.matheclipse.core.expression.F.CI;
import static org.matheclipse.core.expression.F.CN1;
import static org.matheclipse.core.expression.F.CNI;
import static org.matheclipse.core.expression.F.CNPiHalf;
import static org.matheclipse.core.expression.F.CompoundExpression;
import static org.matheclipse.core.expression.F.Condition;
import static org.matheclipse.core.expression.F.DirectedInfinity;
import static org.matheclipse.core.expression.F.Equal;
import static org.matheclipse.core.expression.F.Exp;
import static org.matheclipse.core.expression.F.Greater;
import static org.matheclipse.core.expression.F.GreaterEqual;
import static org.matheclipse.core.expression.F.IInit;
import static org.matheclipse.core.expression.F.ISet;
import static org.matheclipse.core.expression.F.ISetDelayed;
import static org.matheclipse.core.expression.F.IntegerQ;
import static org.matheclipse.core.expression.F.Less;
import static org.matheclipse.core.expression.F.LessEqual;
import static org.matheclipse.core.expression.F.List;
import static org.matheclipse.core.expression.F.Log;
import static org.matheclipse.core.expression.F.Module;
import static org.matheclipse.core.expression.F.N;
import static org.matheclipse.core.expression.F.Negate;
import static org.matheclipse.core.expression.F.Noo;
import static org.matheclipse.core.expression.F.Plus;
import static org.matheclipse.core.expression.F.PossibleZeroQ;
import static org.matheclipse.core.expression.F.Power;
import static org.matheclipse.core.expression.F.ProductLog;
import static org.matheclipse.core.expression.F.Rational;
import static org.matheclipse.core.expression.F.Rationalize;
import static org.matheclipse.core.expression.F.Set;
import static org.matheclipse.core.expression.F.Times;
import static org.matheclipse.core.expression.F.a_;
import static org.matheclipse.core.expression.F.b_;
import static org.matheclipse.core.expression.F.c_;
import static org.matheclipse.core.expression.F.k_;
import static org.matheclipse.core.expression.F.n_;
import static org.matheclipse.core.expression.F.oo;
import static org.matheclipse.core.expression.F.x_;
import static org.matheclipse.core.expression.S.E;
import static org.matheclipse.core.expression.S.Pi;
import static org.matheclipse.core.expression.S.ProductLog;
import static org.matheclipse.core.expression.S.Undefined;
import static org.matheclipse.core.expression.S.a;
import static org.matheclipse.core.expression.S.b;
import static org.matheclipse.core.expression.S.c;
import static org.matheclipse.core.expression.S.k;
import static org.matheclipse.core.expression.S.n;
import static org.matheclipse.core.expression.S.v;
import static org.matheclipse.core.expression.S.x;
import org.matheclipse.core.interfaces.IAST;

/**
 * <p>
 * Generated by <code>org.matheclipse.core.preprocessor.RulePreprocessor</code>.
 * </p>
 * <p>
 * See GIT repository at:
 * <a href="https://github.com/axkr/symja_android_library">github.com/axkr/symja_android_library
 * under the tools directory</a>.
 * </p>
 */
public interface ProductLogRules {
  /**
   * <ul>
   * <li>index 0 - number of equal rules in <code>RULES</code></li>
   * </ul>
   */
  final public static int[] SIZES = {12, 5};

  final public static IAST RULES = List(IInit(ProductLog, SIZES),
      // ProductLog(Undefined)=Undefined
      ISet(ProductLog(Undefined), Undefined),
      // ProductLog(0)=0
      ISet(ProductLog(C0), C0),
      // ProductLog(-Pi/2)=I*Pi/2
      ISet(ProductLog(CNPiHalf), Times(CC(0L, 1L, 1L, 2L), Pi)),
      // ProductLog(-1/E)=-1
      ISet(ProductLog(Negate(Exp(CN1))), CN1),
      // ProductLog(E)=1
      ISet(ProductLog(E), C1),
      // ProductLog(-1,-Pi/2)=-1/2*Pi*I
      ISet(ProductLog(CN1, CNPiHalf), Times(CC(0L, 1L, -1L, 2L), Pi)),
      // ProductLog(-1,-1/E)=-1
      ISet(ProductLog(CN1, Negate(Exp(CN1))), CN1),
      // ProductLog(Infinity)=Infinity
      ISet(ProductLog(oo), oo),
      // ProductLog(-Infinity)=Infinity
      ISet(ProductLog(Noo), oo),
      // ProductLog(I*Infinity)=Infinity
      ISet(ProductLog(DirectedInfinity(CI)), oo),
      // ProductLog(-I*Infinity)=Infinity
      ISet(ProductLog(DirectedInfinity(CNI)), oo),
      // ProductLog(ComplexInfinity)=Infinity
      ISet(ProductLog(CComplexInfinity), oo),
      // ProductLog(Log(x_)*x_):=Log(x)/;x>1/E
      ISetDelayed(ProductLog(Times(Log(x_), x_)), Condition(Log(x), Greater(x, Exp(CN1)))),
      // ProductLog(Log(x_)*a_):=-Log(x)/;0<x&&x<=E&&a<0&&-x*a==1
      ISetDelayed(ProductLog(Times(Log(x_), a_)),
          Condition(Negate(Log(x)),
              And(Less(C0, x), LessEqual(x, E), Less(a, C0), Equal(Times(CN1, x, a), C1)))),
      // ProductLog(E^x_*x_):=x/;x>=-1
      ISetDelayed(ProductLog(Times(Exp(x_), x_)), Condition(x, GreaterEqual(x, CN1))),
      // ProductLog(-1,E^x_*x_):=x/;x<=-1
      ISetDelayed(ProductLog(CN1, Times(Exp(x_), x_)), Condition(x, LessEqual(x, CN1))),
      // ProductLog(Log(b_)*k_/n_*b_^(c_/n_)):=Module({a,v},a=N((n*ProductLog((b^(c/n)*k*Log(b))/n))/Log(b));v=Rationalize(a,0);v*Log(b)/n/;IntegerQ(v)&&v>=1&&PossibleZeroQ(((-b^(c/n)*k+b^(v/n)*v)*Log(b))/n))
      ISetDelayed(
          ProductLog(Times(Log(b_), Rational(k_, n_),
              Power(b_, Rational(c_, n_)))),
          Module(List(a, v),
              CompoundExpression(
                  Set(a,
                      N(Times(n, Power(Log(b), CN1),
                          ProductLog(Times(Power(b, Times(c, Power(n, CN1))), k, Power(n, CN1),
                              Log(b)))))),
                  Set(v, Rationalize(a,
                      C0)),
                  Condition(Times(v, Power(n, CN1), Log(b)),
                      And(IntegerQ(v), GreaterEqual(v, C1),
                          PossibleZeroQ(Times(Power(n, CN1),
                              Plus(Times(CN1, Power(b, Times(c, Power(n, CN1))), k),
                                  Times(Power(b, Times(Power(n, CN1), v)), v)),
                              Log(b)))))))));
}
